easy problems:

344. reverse a string 
class Solution(object):
    def reverseString(self, s):
        """
        :type s: str
        :rtype: str
        """
        #return ''.join(s[i] for i in range(len(s)-1,-1,-1))
        return s[::-1]
        
  
  292. Nim Game
  class Solution(object):
    def canWinNim(self, n):
        """
        :type n: int
        :rtype: bool
        """
        return  False if n %4 == 0 else True
    
    
    371. Sum of Two Integers: no use of +,-
    python code run out of time limit,,,so  change to c++.
    loop carry,add carry.
    class Solution {
    public:
    int getSum(int a, int b) {
        int sum=a;
        int carry=b;
        int tmp;
        while (carry){
            tmp=sum;
            sum^=carry;
            carry=(tmp & carry) << 1;
        }
        return sum;
    }
};


    258. Add Digits
      get inspired by  hints: https://en.wikipedia.org/wiki/Digital_root.  feel so sorry for myself.
      
     class Solution(object):
    def addDigits(self, num):
        """
        :type num: int
        :rtype: int
        """
        return 0 if num == 0 else 1+(num-1) % 9
    
    389. Find the Difference
          use set operation. 
    def findTheDifference(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: str
        """
        res = 0
        for str1 in s:
            res ^= ord(str1)
        for str2 in t:
            res ^= ord(str2)
        return chr(res)
    226. Invert Binary Tree
        #invert from left to right,then swap them.
        def invertTree(self, root):
        if root is None:
            return None
        if root.left:
            self.invertTree(root.left)
        if root.right:
            self.invertTree(root.right)
        root.left, root.right = root.right, root.left
        return root

    141. Linked List Cycle:
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        # fast and slow pointer , if cycle is there, fast can catch up slow in next round.
        if not head or not head.next:
            return False
            
        p = head
        q = head.next
        
        while p and q:
            
            if p == q:
                return True
            p = p.next
            if q.next:
                q = q.next.next
            else:
                return False
        return False

198. House Robber
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
    
        house_ct = len(nums)
        
        if house_ct :
            money_rob = [0]*(house_ct+1)
            money_rob[1] = nums[0]
        else:
            return 0
        
        for i in range(2,house_ct+1):
            
            money_rob[i] = max(money_rob[i-1],money_rob[i-2]+nums[i-1])
            
        return money_rob[house_ct]

107. Binary Tree Level Order Traversal II

def levelOrderBottom(self, root):
        """
        learn to know how to travel a tree level by level.
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        node_list = []
        if not root:
            return node_list
        parent_level = [root]
        while parent_level:
            
            node_list.append([n.val for n in parent_level])# add current lever node in results
            child_level = []
            for node in parent_level:#  move to next level
                if node.left:
                    child_level.append(node.left)
                if node.right:
                    child_level.append(node.right)
            parent_level = child_level
        node_list.reverse()# down to up.
        return node_list
101. Symmetric Tree
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        def is_balance(left,right):
            if not left and not right:
                return True
            if (left and not right) or (not left and right) or left.val != right.val:
                return False
            return is_balance(left.left,right.right) and is_balance(left.right,right.left)
        
        if not root:
            return True
        return is_balance(root.left,root.right)
396. Rotate Function
    # my code, time exceeded.-_-
    
   def maxRotateFunction(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        if not A:
            return 0
            
        def list_rotate(l,k):
            return l[k:]+l[:k]
            
        lens = len(A)
        index_range = range(lens)
        index = list(index_range)
        
        return max([sum([x*y for x,y in zip(list_rotate(A,k),index)]) for k in index_range])
        
        # after online help: 
        def maxRotateFunction(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        if not A:
            return 0
            
        s = sum(A)
        n = len(A)
        
        max_sum = sum([x*y for x,y in zip(A,range(n))])
        tmp = max_sum
        for i in range(1,n):
            tmp = tmp + s - n*A[n-i]
            if tmp > max_sum:
                max_sum = tmp
        return max_sum
