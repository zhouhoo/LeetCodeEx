easy problems:

344. reverse a string 
class Solution(object):
    def reverseString(self, s):
        """
        :type s: str
        :rtype: str
        """
        #return ''.join(s[i] for i in range(len(s)-1,-1,-1))
        return s[::-1]
        
  
  292. Nim Game
  class Solution(object):
    def canWinNim(self, n):
        """
        :type n: int
        :rtype: bool
        """
        return  False if n %4 == 0 else True
    
    
    371. Sum of Two Integers: no use of +,-
    python code run out of time limit,,,so  change to c++.
    loop carry,add carry.
    class Solution {
    public:
    int getSum(int a, int b) {
        int sum=a;
        int carry=b;
        int tmp;
        while (carry){
            tmp=sum;
            sum^=carry;
            carry=(tmp & carry) << 1;
        }
        return sum;
    }
};


    258. Add Digits
      get inspired by  hints: https://en.wikipedia.org/wiki/Digital_root.  feel so sorry for myself.
      
     class Solution(object):
    def addDigits(self, num):
        """
        :type num: int
        :rtype: int
        """
        return 0 if num == 0 else 1+(num-1) % 9
    
    389. Find the Difference
          use set operation. 
    def findTheDifference(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: str
        """
        res = 0
        for str1 in s:
            res ^= ord(str1)
        for str2 in t:
            res ^= ord(str2)
        return chr(res)
    226. Invert Binary Tree
        #invert from left to right,then swap them.
        def invertTree(self, root):
        if root is None:
            return None
        if root.left:
            self.invertTree(root.left)
        if root.right:
            self.invertTree(root.right)
        root.left, root.right = root.right, root.left
        return root

    141. Linked List Cycle:
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        # fast and slow pointer , if cycle is there, fast can catch up slow in next round.
        if not head or not head.next:
            return False
            
        p = head
        q = head.next
        
        while p and q:
            
            if p == q:
                return True
            p = p.next
            if q.next:
                q = q.next.next
            else:
                return False
        return False

198. House Robber
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
    
        house_ct = len(nums)
        
        if house_ct :
            money_rob = [0]*(house_ct+1)
            money_rob[1] = nums[0]
        else:
            return 0
        
        for i in range(2,house_ct+1):
            
            money_rob[i] = max(money_rob[i-1],money_rob[i-2]+nums[i-1])
            
        return money_rob[house_ct]
